####################
# Code generated by EntPy - do not modify manually!
####################

from __future__ import annotations
from entpy import Ent, generate_uuid, EntNotFoundError, ExecutionError, Action, Decision
from uuid import UUID
from datetime import datetime, UTC
from typing import Self
from abc import ABC
from evc import ExampleViewerContext
from database import get_session
from sqlalchemy import String
from .ent_model import EntModel
from entpy import Field
from sentinels import NOTHING, Sentinel  # type: ignore
from typing import Any, TypeVar, Generic
from sqlalchemy.sql.expression import ColumnElement
from .ent_test_thing import EntTestThingModel
from ent_test_object2_schema import EntTestObject2Schema
from sqlalchemy import select, Select, func, Result
from sqlalchemy.orm import Mapped, mapped_column
from .ent_test_thing import IEntTestThing


class EntTestObject2Model(EntTestThingModel):
    __tablename__ = "test_object2"

    some_field: Mapped[str | None] = mapped_column(String(100), nullable=True)


class EntTestObject2(IEntTestThing, Ent[ExampleViewerContext]):
    vc: ExampleViewerContext
    model: EntTestObject2Model

    def __init__(self, vc: ExampleViewerContext, model: EntTestObject2Model) -> None:
        self.vc = vc
        self.model = model

    @property
    def id(self) -> UUID:
        return self.model.id

    @property
    def created_at(self) -> datetime:
        return self.model.created_at

    @property
    def updated_at(self) -> datetime:
        return self.model.updated_at

    @property
    def a_good_thing(self) -> str:
        return self.model.a_good_thing

    @property
    def some_field(self) -> str | None:
        return self.model.some_field

    async def _gen_evaluate_privacy(
        self, vc: ExampleViewerContext, action: Action
    ) -> Decision:
        rules = EntTestObject2Schema().get_privacy_rules(action)
        for rule in rules:
            decision = await rule.gen_evaluate(vc, self)
            # If we get an ALLOW or DENY, we return instantly. Else, we keep going.
            if decision != Decision.PASS:
                return decision
        # We default to denying
        return Decision.DENY

    @classmethod
    async def genx(cls, vc: ExampleViewerContext, ent_id: UUID) -> EntTestObject2:
        ent = await cls.gen(vc, ent_id)
        if not ent:
            raise EntNotFoundError(f"No EntTestObject2 found for ID {ent_id}")
        return ent

    @classmethod
    async def gen(cls, vc: ExampleViewerContext, ent_id: UUID) -> EntTestObject2 | None:
        session = get_session()
        model = await session.get(EntTestObject2Model, ent_id)
        return await cls._gen_from_model(vc, model)

    @classmethod
    async def _gen_from_model(
        cls, vc: ExampleViewerContext, model: EntTestObject2Model | None
    ) -> EntTestObject2 | None:
        if not model:
            return None
        ent = EntTestObject2(vc=vc, model=model)
        decision = await ent._gen_evaluate_privacy(vc=vc, action=Action.READ)
        return ent if decision == Decision.ALLOW else None

    @classmethod
    async def _genx_from_model(
        cls, vc: ExampleViewerContext, model: EntTestObject2Model
    ) -> EntTestObject2:
        ent = await EntTestObject2._gen_from_model(vc=vc, model=model)
        if not ent:
            raise EntNotFoundError(f"No EntTestObject2 found for ID {model.id}")
        return ent

    @classmethod
    def query(cls, vc: ExampleViewerContext) -> EntTestObject2ListQuery:
        return EntTestObject2ListQuery(vc=vc)

    @classmethod
    def query_count(cls, vc: ExampleViewerContext) -> EntTestObject2CountQuery:
        return EntTestObject2CountQuery()


T = TypeVar("T")


class EntTestObject2Query(ABC, Generic[T]):
    query: Select[tuple[T]]

    def join(self, model_class: type[EntModel], predicate: ColumnElement[bool]) -> Self:
        self.query = self.query.join(model_class, predicate)
        return self

    def where(self, predicate: ColumnElement[bool]) -> Self:
        self.query = self.query.where(predicate)
        return self

    def order_by(self, predicate: ColumnElement[Any]) -> Self:
        self.query = self.query.order_by(predicate)
        return self

    def limit(self, limit: int) -> Self:
        self.query = self.query.limit(limit)
        return self


class EntTestObject2ListQuery(EntTestObject2Query[EntTestObject2Model]):
    vc: ExampleViewerContext

    def __init__(self, vc: ExampleViewerContext) -> None:
        self.vc = vc

        self.query = select(EntTestObject2Model)

    async def gen(self) -> list[EntTestObject2]:
        session = get_session()
        result = await session.execute(self.query)
        ents = await self._gen_ents(result)
        return list(filter(None, ents))

    async def _gen_ents(
        self, result: Result[tuple[EntTestObject2Model]]
    ) -> list[EntTestObject2 | None]:
        models = result.scalars().all()
        return [
            await EntTestObject2._gen_from_model(self.vc, model) for model in models
        ]

    async def gen_first(self) -> EntTestObject2 | None:
        session = get_session()
        result = await session.execute(self.query.limit(1))
        return await self._gen_ent(result)

    async def _gen_ent(
        self, result: Result[tuple[EntTestObject2Model]]
    ) -> EntTestObject2 | None:
        model = result.scalar_one_or_none()
        return await EntTestObject2._gen_from_model(self.vc, model)

    async def genx_first(self) -> EntTestObject2:
        ent = await self.gen_first()
        if not ent:
            raise EntNotFoundError("Expected query to return an ent, got None.")
        return ent


class EntTestObject2CountQuery(EntTestObject2Query[int]):
    def __init__(self) -> None:
        self.query = select(func.count()).select_from(EntTestObject2Model)

    async def gen_NO_PRIVACY(self) -> int:
        session = get_session()
        result = await session.execute(self.query)
        count = result.scalar()
        if count is None:
            raise ExecutionError("Unable to get the count")
        return count


class EntTestObject2Mutator:
    @classmethod
    def create(
        cls,
        vc: ExampleViewerContext,
        a_good_thing: str,
        some_field: str | None = None,
        id: UUID | None = None,
        created_at: datetime | None = None,
    ) -> EntTestObject2MutatorCreationAction:
        return EntTestObject2MutatorCreationAction(
            vc=vc,
            id=id,
            created_at=created_at,
            a_good_thing=a_good_thing,
            some_field=some_field,
        )

    @classmethod
    def update(
        cls, vc: ExampleViewerContext, ent: EntTestObject2
    ) -> EntTestObject2MutatorUpdateAction:
        return EntTestObject2MutatorUpdateAction(vc=vc, ent=ent)

    @classmethod
    def delete(
        cls, vc: ExampleViewerContext, ent: EntTestObject2
    ) -> EntTestObject2MutatorDeletionAction:
        return EntTestObject2MutatorDeletionAction(vc=vc, ent=ent)


class EntTestObject2MutatorCreationAction:
    vc: ExampleViewerContext
    id: UUID
    a_good_thing: str
    some_field: str | None = None

    def __init__(
        self,
        vc: ExampleViewerContext,
        id: UUID | None,
        created_at: datetime | None,
        a_good_thing: str,
        some_field: str | None,
    ) -> None:
        self.vc = vc
        self.created_at = created_at if created_at else datetime.now(tz=UTC)
        self.id = id if id else generate_uuid(EntTestObject2, self.created_at)
        self.a_good_thing = a_good_thing
        self.some_field = some_field

    async def gen_savex(self) -> EntTestObject2:
        session = get_session()
        model = EntTestObject2Model(
            id=self.id,
            created_at=self.created_at,
            a_good_thing=self.a_good_thing,
            some_field=self.some_field,
        )
        session.add(model)
        await session.flush()
        # TODO privacy checks
        return await EntTestObject2._genx_from_model(self.vc, model)


class EntTestObject2MutatorUpdateAction:
    vc: ExampleViewerContext
    ent: EntTestObject2
    id: UUID
    a_good_thing: str
    some_field: str | None = None

    def __init__(self, vc: ExampleViewerContext, ent: EntTestObject2) -> None:
        self.vc = vc
        self.ent = ent
        self.a_good_thing = ent.a_good_thing
        self.some_field = ent.some_field

    async def gen_savex(self) -> EntTestObject2:
        session = get_session()
        model = self.ent.model
        model.a_good_thing = self.a_good_thing
        model.some_field = self.some_field
        session.add(model)
        await session.flush()
        # TODO privacy checks
        return await EntTestObject2._genx_from_model(self.vc, model)


class EntTestObject2MutatorDeletionAction:
    vc: ExampleViewerContext
    ent: EntTestObject2

    def __init__(self, vc: ExampleViewerContext, ent: EntTestObject2) -> None:
        self.vc = vc
        self.ent = ent

    async def gen_save(self) -> None:
        session = get_session()
        model = self.ent.model
        # TODO privacy checks
        await session.delete(model)
        await session.flush()


class EntTestObject2Example:
    @classmethod
    async def gen_create(
        cls,
        vc: ExampleViewerContext,
        created_at: datetime | None = None,
        a_good_thing: str | Sentinel = NOTHING,
        some_field: str | None = None,
    ) -> EntTestObject2:
        # TODO make sure we only use this in test mode

        a_good_thing = (
            "A sunny day" if isinstance(a_good_thing, Sentinel) else a_good_thing
        )

        return await EntTestObject2Mutator.create(
            vc=vc,
            created_at=created_at,
            a_good_thing=a_good_thing,
            some_field=some_field,
        ).gen_savex()

    @classmethod
    def _get_field(cls, field_name: str) -> Field:
        schema = EntTestObject2Schema()
        fields = schema.get_fields()
        field = list(
            filter(
                lambda field: field.name == field_name,
                fields,
            )
        )[0]
        if not field:
            raise ValueError(f"Unknown field: {field_name}")
        return field
